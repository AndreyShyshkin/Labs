<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link rel="stylesheet" type="text/css" href="../../style.css">
</head>

<body>
<a name="top"></a>
<h1><b>8. Покажчики та посилання. Покажчики на функції. Масиви покажчиків</b></h1>
<em>Мета  роботи:</em>
<ol>
  <li>
    Ознайомитися  з особливостями посилальних типів даних;
  </li>
  <li>
    Опанувати технологію застосування посилальних типів даних;
  </li>
  <li>
    Навчитися розробляти алгоритми та програми із застосуванням посилальних типів даних.
  </li>
</ol>
<h2>8.1. Теоретичні відомості</h2>
<h3><span style="color: #00C">8.1.1. Основні поняття</span><br>
</h3>
<p>До посилальних типів  відносяться покажчики та посилання. Покажчики дозволяють працювати з адресами  комірок оперативної пам&rsquo;яті, тим самим вони реалізують непрямий доступ до їх  вмісту. Посилання є альтернативними іменами змінних. Застосування покажчиків і  посилань як параметрів функцій дозволяє функції змінювати значення своїх  аргументів, отже, повертати в програму більше ніж одне значення. </p>
Змінні,  що зберігають адреси інших змінних, називаються <em><strong>змінними-покажчиками </strong></em>чи просто<em> <strong>покажчиками</strong></em>. <br>Для  визначення адреси змінної означена операція &amp; отримання адреси. <br>Якщо  оголошена та ініціалізована змінна, наприклад, int value=10, її адресу можна  визначити виразом &amp;value. <br>Якщо значення, що зберігаються, займатимуть  послідовність байтів, покажчик адресує перший байт цієї послідовності.<br>
<br>
<h3 style="color: #00C">8.1.2. Оголошення та ініціалізація</h3>
<p>Константні значення,  арифметичні вирази та регістрові змінні не зберігають значення в оперативній  пам&rsquo;яті, тому застосувати до них операцію &amp; неприпустимо. <br>
<strong>Змінну-покажчик  оголошують:</strong><br>
<span class="light">&lt;тип&gt;</span>* &lt;ідентифікатор_&shy;покажчика&gt;;<br>
Тут <span class="light">&lt;тип&gt;</span> &mdash; простий чи структурований тип адресованої  змінної; &lt;ідентифікатор_&shy;покажчика&gt; &mdash; рядок символів, що є ім&rsquo;ям змінної-покажчика; символ * означає &laquo;вказати  на&raquo;. <br>
Покажчик перед  використанням <strong>iнiцiалiзується </strong>адресою змінної або значенням іншого покажчика.  Покажчику можна присвоїти значення <strong>0 (NULL).</strong>Такий покажчик не адресує жодну змінну.<br><br>
<strong>Посилання</strong>&nbsp;є  псевдонімом змінної, тобто її альтернативним іменем і для нього не  резервується&nbsp; місце в оперативній  пам&rsquo;яті. 
<strong>Синтаксис оголошення посилання</strong> застосовує символ &amp;, який записують  після типу змінної:<br>
<span class="light">&lt;тип&gt;</span>&amp;  &lt;ідентифікатор_посилання &gt;;&nbsp; </p>
Посилання  слід <strong>iнiцiалiзувати</strong> ім&rsquo;ям змінної. Типи посилання та змінної, значенням якої  ініціалізуються посилання, мають збігатися.<br>
<br>
<h3 style="color: #00C">8.1.3. Операції над покажчиками</h3>
<p>Для покажчиків означені  операції <em><strong>адресування, присвоєння,  арифметичні та відношення. </strong></em><br>
<ol>
<li>  Унарна операція &amp; повертає адресу свого аргументу.</li>
  <li>Значення змінної за певною адресою отримують,  застосувавши операцію <em>розименування</em>. Операція позначається символом *, який записують перед іменем покажчика. Операція * повертає об&rsquo;єкт, на який вказує покажчик.</li>
  <li>Операція <em>присвоєння</em> використовується для надання  значення покажчику.</li>
  <li><em>Арифметичні операції</em>: 
 <ol>
<li type=a>унарні операції інкремента та декремента,</li>
<li type=a> бінарні операції додавання та віднімання  цілого числа, </li>
<li type=a>віднімання одного покажчика з іншого.</li><br>
</ol>
  <li> Порівняння покажчиків. Покажчики одного типу  можна <em>порівнювати</em> один з одним. При  цьому порівнюються адреси, що зберігаються в покажчиках. </li>
</ol>

  <strong><em>Покажчик на функцію</em></strong> містить адресу її в оперативній пам&rsquo;яті. Ім&rsquo;я  функції &mdash; це початкова адреса її коду. До функцій можна застосувати тільки дві  операції: виклик і отримання її адреси, тобто визначити її покажчик. <br>
  <strong>Синтаксис оголошення  покажчика на функцію:</strong><br>
  &nbsp;<span class="light">&lt;тип&gt;</span> (*&lt;ідентифікатор  покажчика&gt;)(&lt;оголошення параметрів&gt;);<br>
  Щоб викликати функцію  через покажчик, його слід <strong>розименувати.</strong><br><br>
  Існують три способи  передачі аргументів у функцію &mdash; як значення, як посилання та як покажчики. <br>Щоб  повертати з функцій більше одного значення, слід передати функції  аргументи-посилання або аргументи-покажчики. Під час оголошення функції  параметри-посилання вказують у її заголовку, використовуючи операцію посилання &amp;. Параметри-покажчики оголошують в заголовку  функції, використовуючи операцію непрямої адресації *. </p>
В  операціях виклику функції з аргументом-покажчиком застосовується операція &amp;  адресації&nbsp; змінної, значення котрої  змінюватимуться. В операції виклику функції з параметром-посилання аргументом є  ім&rsquo;я змінної.<br>
<br>
<h3 style="color: #00C">8.1.4. Методи розв&rsquo;язанні нелінійних рівнянь</h3>
<p><em><strong>Метод перебору.</strong></em> При розв&rsquo;язанні нелінійного рівняння методом перебору задаються початкове  значення аргументу <em>x=a</em> і крок <em>h</em>, який при цьому визначає і точність знаходження  коріння нелінійного рівняння. Поки виконується умова <em>F(x)*F(x+h)</em>&gt;0 аргумент  <em>x</em> збільшуємо на крок <em>h (x = x + h)</em>. Якщо добуток <em>F(x)*F(x+h)</em> стає від&rsquo;ємним , то на  інтервалі [<em>x, x+h</em>] існує розв&rsquo;язок рівняння.<br><br>

 <em><strong>Метод половинного ділення.</strong></em> При розв&rsquo;язанні нелінійного рівняння методом  половинного ділення задаються інтервал [<em>a, b</em>], на якому існує тільки одне  рішення, і бажана точність &epsilon;. Потім визначається середина інтервалу <em>с = (а + b)</em>/2 і  перевіряється умова <em>F(a)*F(c)</em>&lt;0. Якщо вказана умова виконується, то праву  межу інтервалу <em>b</em> переносимо в середню точку <em>с (b=c)</em>. Якщо умова не виконується,  то в середню точку переносимо ліву межу (<em>a = c</em>). Ділення відрізку навпіл триває  доки |<em>b - a</em>|&gt;&epsilon;.  <br><br>

  <em><strong>Метод хорд</strong></em>. При розв&rsquo;язанні нелінійного рівняння методом хорд задаються інтервал [<em>a,  b</em>], на якому існує тільки одне рішення, і точність &epsilon;. Потім через дві точки з  координатами <em>(a, F(a))</em> і <em>(b, F(b))</em> проводимо відрізок прямої лінії (хорду) і  визначаємо точку перетину цієї лінії з віссю абсцис (точка <em>c</em>). Якщо при цьому  <em>F(a)*F(c)</em>&lt;0, то праву межу інтервалу переносимо в точку<em>с (b=c)</em>. Якщо вказана умова не виконується, то в точку <em>c</em> переноситься ліва межа інтервалу (<em>а = с</em>). Пошук рішення припиняється, коли досягається задана точність |<em>F(c)</em>|&lt;&epsilon;. Для визначення точки перетину хорди з віссю абсцис використовується формула <img src="pictures/t1.gif" width="175" height="42" align="middle">&nbsp;.</p>
<em><strong>Метод дотичних</strong></em>.  При розв&rsquo;язанні нелінійного рівняння методом дотичних задаються початкове  значення аргументу <em>x0</em> і точність &epsilon;. Потім в точці(<em>x0, F(x0)</em>) проводимо дотичну  до графіка <em>F(x)</em> і визначаємо точку <em>x</em>1 перетину дотичної з віссю абсцис . У точці  (<em>x1, F(x1)</em>) знову будуємо дотичну, знаходимо наступне наближення шуканого  рішення <em>x</em>2 і так далі. Вказану процедуру повторюємо доки |<em>F(xi)</em>|&gt; &epsilon;. Для  визначення точки перетину  дотичної з віссю абсцис використовується  формула <img src="pictures/t2.gif" width="115" height="39" align="middle">&nbsp;Умова  збіжності методу дотичних <img src="pictures/t3.gif" width="119" height="16" />.<br>

<h3 style="color: #00C">8.1.5. Обробка розріджених матриць</h3>
<p>Розрідженою матрицею називається матриця, в якій кількість нульових елементів набагато переважає над ненульовими. У таких матрицях кількість ненульових елементів становить до 20%. Робота з розрідженій матрицею передбачає особливі способи доступу до елементів. Для спрощення цієї роботи були розроблені спеціальні формати зберігання ненульових елементів матриці.
<br>
<strong><em> Формати зберігання розрідженої матриці.</em> </strong> 
Існує п'ять найбільш поширених форматів зберігання розріджених матриць:
<ol>
<li> Coordinate Storage (COO - координатний формат), </li>
<li> Compressed Row Storage (CRS - розріджений рядковий формат), </li>
<li> Compressed Column Storage (CCS - розріджений столбцовий формат),  </li>
<li> Row-wise Representation Complete and Ordered (RR (C) O - упорядкований рядковий формат),</li>
<li> Column-wise Representation Complete and Ordered (CR (C) O - упорядкований столбцовий формат).</li>
</ol>
<strong><em>Координатний формат СОО.</em></strong> Матриця представляється у вигляді трьох одновимірних масивів, перший з яких зберігає значення ненульових елементів матриці, другий і третій  - номери рядків і стовпців цих елементів відповідно. Розміри масивів відповідаю кількості ненульових елементів. Приклад збереження розрідженої матриці за форматом СОО: <br><img src="pictures/theory1.png"><br><br>

<strong><em>Розріджений рядковий формат CRS. </em></strong> Матриця <em>A</em> представляється у вигляді трьох одновимірних масивів. Значення ненульових елементів зберігаються в масиві <em>AN</em>, відповідні їм індекси стовпців - в масиві <em>JA</em>. Розмірності <em>NNZ</em> цих одновимірних масивів однакові, дорівнюють кількоcті ненульових елементів розрідженої матриці. Крім того, використовується масив покажчиків рядків <em>IA</em>, які відзначають позиції ненульового елемента <em>AN</em> і відповідного стовпця  <em>JA</em>, з яких починаються опис чергового рядка. Тобто на <em>k</em>-ому місці в масиві <em>IA</em> зберігається позиція першого ненульового елемента <em>k</em>-ого рядка в масиві  <em>AN</em>. Масив покажчиків може містити додатковий кінцевий елемент, для якого встановлено значення <em>NNZ</em>. Приклад збереження розрідженої матриці за форматом CRS: <br><img src="pictures/theory2.png"><br><br>

<br><strong><em>Упорядкований  рядковий формат RR (C) O.</em></strong> Матриця <em>A</em> представляється у вигляді трьох одновимірних масивів. Значення ненульових елементів зберігаються в масиві <em>AN</em>, відповідні їм індекси стовпців - в масиві <em>JA</em>.  Розмірності <em>NNZ</em> цих одновимірних масивів однакові, дорівнюють кількоcті ненульових елементів розрідженої матриці. 
Масив покажчиків <em>IA</em> використовується для посилання на компоненти масивів <em>AN</em> і <em>JA</em>, з яких починається опис чергового рядка. Остання компонента масиву <em>IA</em> містить покажчик першої вільної компоненти в масивах <em>AN</em> і <em>JA</em>, тобто дорівнює кількості ненульових елементів матриці, збільшеній на одиницю.
Приклад збереження розрідженої матриці за форматом RR (C) O:<br><img src="pictures/theory3.png"><br><br>
Масив <em>IA</em> містить номер, з якого починається опис елементів в масивах <em>AN</em> і <em>JA</em>. Таким чином інформація про елементи 3-го рядка матриці зберігатися в елементах з 
<em>IA</em> [3] = 4 по <em>IA</em> [4] -1 = 5 масивів <em>AN</em> і <em>JA</em>. Оскільки <em>IA</em> (2) = </em>IA</em> (3) = 4, то це означає, що другий рядок матриці <em>A</em> нульовий.[<a href="#1">1] [<a href="#2">2][<a href="#3">3] [<a href="#4">4] </a> 

<p> <strong>  Корисні джерела</strong>
</p>
<a name="1">
 <a href="https://avidreaders.ru/download/tehnologiya-razrezhennyh-matric.html?f=djvu" target="_blank"> 1. Писсанецки С. Технология разреженных матриц</a> <br>
 <a name="2"><a href="https://www.twirpx.com/file/1351861/" target="_blank">2. Тьюарсон, Р. Разреженные матрицы : Науч. литература. – М.: Изд-во МИР, 1977. – 191 с</a> <br>
 <a name="3">
 <a href="http://5.100.98.127/ftp/%D0%A2%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/Algorithms/alglib.chat.ru_80/paper/zeromatr.html" target="_blank">3. Представление разреженных матриц.</a> <br>
<a name="4">
 <a href="http://5.100.98.127/ftp/%D0%A2%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/Algorithms/alglib.chat.ru_80/linalg/index3.html#toppage" 4target="_blank">4. Работа с разреженными матрицами </a> <br>


</p>
<p><a href="#top">Вверх</a></p>
</body>
</html>